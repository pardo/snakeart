{"version":3,"sources":["node_modules/roughjs/bin/path.js","node_modules/roughjs/bin/geometry.js","node_modules/roughjs/bin/utils/hachure.js","node_modules/roughjs/bin/fillers/filler-utils.js","node_modules/roughjs/bin/fillers/hachure-filler.js","node_modules/roughjs/bin/fillers/zigzag-filler.js","node_modules/roughjs/bin/fillers/hatch-filler.js","node_modules/roughjs/bin/fillers/dot-filler.js","node_modules/roughjs/bin/fillers/filler.js","node_modules/roughjs/bin/renderer.js","node_modules/roughjs/bin/renderer-factory.js","node_modules/roughjs/bin/generator-base.js","node_modules/roughjs/bin/generator.js","node_modules/roughjs/bin/canvas-base.js","node_modules/roughjs/bin/canvas.js","node_modules/roughjs/bin/generator-async.js","node_modules/roughjs/bin/canvas-async.js","node_modules/roughjs/bin/svg-base.js","node_modules/roughjs/bin/svg.js","node_modules/roughjs/bin/svg-async.js","node_modules/roughjs/bin/rough.js","drawable.js","helpers.js","node_modules/rainbowvis.js/rainbowvis.js","index.js"],"names":["isType","token","type","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","ParsedPath","constructor","d","COMMAND","NUMBER","EOD","segments","parseData","processPoints","tokenize","tokens","Array","match","substr","RegExp","$1","length","text","console","error","parseFloat","index","mode","param_length","params","i","numbeToken","segment","key","data","push","closed","_closed","toLowerCase","first","currentPoint","point","RoughPath","_position","_first","bezierReflectionPoint","quadReflectionPoint","parsed","linearPoints","_linearPoints","lp","points","setPosition","x","y","position","RoughArcConverter","from","to","radii","angle","largeArcFlag","sweepFlag","_segIndex","_numSegs","_rx","_ry","_sinPhi","_cosPhi","_C","_theta","_delta","_T","_from","radPerDeg","Math","PI","abs","sin","cos","x1dash","y1dash","root","numerator","sqrt","cxdash","cydash","calculateVectorAngle","dtheta","ceil","getNextSegment","cosTheta1","sinTheta1","theta2","cosTheta2","sinTheta2","cp1","cp2","ux","uy","vx","vy","ta","atan2","tb","PathFitter","sets","fit","simplification","outSets","set","estLength","floor","reduce","distance","p1","p2","pow","count","slice","areas","minArea","minIndex","b","area","splice","Segment","xi","Number","MAX_VALUE","yi","px1","py1","px2","py2","_undefined","isUndefined","intersects","otherSegment","grad1","grad2","int1","int2","min","max","HachureIterator","top","bottom","left","right","gap","sinAngle","cosAngle","tanAngle","deltaX","hGap","pos","sLeft","sRight","nextLine","line","xLower","xUpper","yLower","yUpper","lineLength","getIntersectingLines","intersections","s1","s2","affine","cx","cy","sinAnglePrime","cosAnglePrime","R","hachureLinesForPolygon","o","ret","hachureAngle","hachureGap","strokeWidth","tan","it","rect","lines","hachureLinesForEllipse","width","height","renderer","rx","ry","getOffset","fweight","fillWeight","aspectRatio","hyp","gapPrime","halfLen","xPos","HachureFiller","fillPolygon","_fillPolygon","fillEllipse","_fillEllipse","connectEnds","ops","renderLines","prevPoint","concat","doubleLine","ZigZagFiller","HatchFiller","o2","Object","assign","set2","DotFiller","curveStepCount","dotsOnLines","dl","alpha","atan","dy","dx","ellipse","fillers","getFiller","fillerName","fillStyle","RoughRenderer","x1","y1","x2","y2","linearPath","close","len","polygon","rectangle","curve","o1","_curveWithOffset","roughness","increment","_ellipse","arc","start","stop","roughClosure","strt","stp","ellipseInc","arcInc","_arc","op","svgPath","path","replace","p","fitter","prev","opList","_processSegment","solidFillPolygon","offset","maxRandomnessOffset","patternFillPolygon","filler","patternFillEllipse","patternFillArc","random","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","_curve","closePoint","curveTightness","cachedVertArray","ro","overlap","radOffset","ps","_bezierTo","ros","f","seg","prevSeg","delta","ob","prevKey","ref","offset1","offset2","arcConverter","hasSelf","self","roughScript","document","currentScript","src","createRenderer","config","workly","async","noWorker","worklySource","worklyURL","code","ourl","URL","createObjectURL","Blob","proxy","RoughGeneratorBase","surface","defaultOptions","stroke","options","_options","_drawable","shape","lib","getCanvasSize","val","w","baseVal","value","computePolygonSize","polygonPath","computePathSize","size","ns","svg","createElementNS","setAttribute","pathNode","appendChild","body","bb","getBBox","removeChild","err","canvasSize","toPaths","drawable","paths","drawing","opsToPath","fill","fillSketch","pattern","viewBox","round","patternUnits","item","trim","RoughGenerator","circle","diameter","fillPoints","hasDocument","RoughCanvasBase","canvas","ctx","getContext","draw","getDefaultOptions","save","strokeStyle","lineWidth","_drawToContext","restore","p2d","Path2D","doc","ownerDocument","hcanvas","createElement","hcontext","bbox","computeBBox","translate","createPattern","beginPath","moveTo","bezierCurveTo","quadraticCurveTo","lineTo","RoughCanvas","gen","generator","RoughGeneratorAsync","RoughCanvasAsync","genAsync","RoughSVGBase","defs","_defs","dnode","firstChild","insertBefore","g","style","id","MAX_SAFE_INTEGER","patternPath","RoughSVG","RoughSVGAsync","Drawable","createAndAppend","parent","element","context2d","roughCanvas","rough","resize","getSize","clear","clearRect","goFullscreen","elem","requestFullscreen","msRequestFullscreen","mozRequestFullScreen","webkitRequestFullscreen","FisherYatesShuffle","myArray","j","tempi","tempj","range","end","step","arguments","distancePoints","distanceXY","rad2deg","deg2rad","angleBetweenXY","log","pointFollowingAnglePoint","mapObj","func","obj","keys","result","getWindowSizePoint","winW","winH","offsetWidth","offsetHeight","compatMode","documentElement","window","innerWidth","innerHeight","getElementSize","downloadText","filename","pom","encodeURIComponent","click","getId","base62","str","debounce","wait","immediate","timeout","context","args","callNow","clearTimeout","setTimeout","apply","throttle","throttling","more","whenDone","changeColorLuminance","hex","lum","String","rgb","parseInt","toString","randomHexColor","isTouchDevice","TOP_LINE","RIGHT_LINE","BOTTOM_LINE","LEFT_LINE","ALL_LINES","drawGrid","gridOptions","forEach","drawNormalBlockLines","lineOptions","strokeColor","drawBlock","margin","e","k","n","color","drawNormalBlock","getGrayShade","Snaker","visitedPositions","intialPositions","blocksPending","colorIndex","rainbow","Rainbow","grayScaleColors","map","setSpectrum","setNumberRange","colors","colorAt","reset","setGridSize","nextColor","drawTillEnd","getSnake","dataPoint","drawLoop","setInterval","shift","getEmptyPoint","Error","pop","isVisited","markVisited","undefined","includes","getSnakeNextPoint","directions","direction","nextPoint","getLinesForDirections","previousDirection","getHachureAngleForDirections","snake","snaker","addEventListener","main","getElementById","which"],"mappings":"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,SACA,eAAA,SACA,SAAA,SACA,QAAA,SACA,KAAA,SACA,SAAA,SACA,SAAA,SACA,cAAA,SACA,SAAA,SACA,UAAA,SACA,SAAA,SACA,UAAA,SACA,YAAA,SACA,eAAA,SACA,WAAA,SACA,WAAA,SACA,QAAA,SACA,WAAA,SACA,aAAA,SACA,cAAA,SACA,cAAA,SACA,cAAA,SACA,cAAA,SACA,WAAA,SACA,SAAA,SACA,YAAA,SACA,QAAA,SACA,QAAA,SACA,WAAA,SACA,UAAA,SACA,YAAA,SACA,YAAA,SACA,QAAA,SACA,UAAA,SACA,WAAA,SACA,KAAA,SACA,UAAA,SACA,KAAA,SACA,MAAA,SACA,YAAA,SACA,KAAA,SACA,SAAA,SACA,QAAA,SACA,UAAA,SACA,OAAA,SACA,MAAA,SACA,MAAA,SACA,SAAA,SACA,cAAA,SACA,UAAA,SACA,aAAA,SACA,UAAA,SACA,WAAA,SACA,UAAA,SACA,qBAAA,SACA,UAAA,SACA,WAAA,SACA,UAAA,SACA,UAAA,SACA,YAAA,SACA,cAAA,SACA,aAAA,SACA,eAAA,SACA,eAAA,SACA,eAAA,SACA,YAAA,SACA,KAAA,SACA,UAAA,SACA,MAAA,SACA,QAAA,SACA,OAAA,SACA,iBAAA,SACA,WAAA,SACA,aAAA,SACA,aAAA,SACA,eAAA,SACA,gBAAA,SACA,kBAAA,SACA,gBAAA,SACA,gBAAA,SACA,aAAA,SACA,UAAA,SACA,UAAA,SACA,SAAA,SACA,YAAA,SACA,KAAA,SACA,QAAA,SACA,MAAA,SACA,UAAA,SACA,OAAA,SACA,UAAA,SACA,OAAA,SACA,cAAA,SACA,UAAA,SACA,cAAA,SACA,cAAA,SACA,WAAA,SACA,UAAA,SACA,KAAA,SACA,KAAA,SACA,KAAA,SACA,WAAA,SACA,OAAA,SACA,IAAA,SACA,UAAA,SACA,UAAA,SACA,YAAA,SACA,OAAA,SACA,WAAA,SACA,SAAA,SACA,SAAA,SACA,OAAA,SACA,OAAA,SACA,QAAA,SACA,UAAA,SACA,UAAA,SACA,UAAA,SACA,KAAA,SACA,YAAA,SACA,UAAA,SAC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","file":"snakeart.96c48f0f.map","sourceRoot":"..","sourcesContent":["function isType(token, type) {\n    return token.type === type;\n}\nconst PARAMS = {\n    A: 7,\n    a: 7,\n    C: 6,\n    c: 6,\n    H: 1,\n    h: 1,\n    L: 2,\n    l: 2,\n    M: 2,\n    m: 2,\n    Q: 4,\n    q: 4,\n    S: 4,\n    s: 4,\n    T: 4,\n    t: 2,\n    V: 1,\n    v: 1,\n    Z: 0,\n    z: 0\n};\nclass ParsedPath {\n    constructor(d) {\n        this.COMMAND = 0;\n        this.NUMBER = 1;\n        this.EOD = 2;\n        this.segments = [];\n        this.parseData(d);\n        this.processPoints();\n    }\n    tokenize(d) {\n        const tokens = new Array();\n        while (d !== '') {\n            if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n                tokens[tokens.length] = { type: this.COMMAND, text: RegExp.$1 };\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n                tokens[tokens.length] = { type: this.NUMBER, text: `${parseFloat(RegExp.$1)}` };\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                console.error('Unrecognized segment command: ' + d);\n                return [];\n            }\n        }\n        tokens[tokens.length] = { type: this.EOD, text: '' };\n        return tokens;\n    }\n    parseData(d) {\n        const tokens = this.tokenize(d);\n        let index = 0;\n        let token = tokens[index];\n        let mode = 'BOD';\n        this.segments = new Array();\n        while (!isType(token, this.EOD)) {\n            let param_length;\n            const params = new Array();\n            if (mode === 'BOD') {\n                if (token.text === 'M' || token.text === 'm') {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n                else {\n                    this.parseData('M0,0' + d);\n                    return;\n                }\n            }\n            else {\n                if (isType(token, this.NUMBER)) {\n                    param_length = PARAMS[mode];\n                }\n                else {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n            }\n            if ((index + param_length) < tokens.length) {\n                for (let i = index; i < index + param_length; i++) {\n                    const numbeToken = tokens[i];\n                    if (isType(numbeToken, this.NUMBER)) {\n                        params[params.length] = +numbeToken.text;\n                    }\n                    else {\n                        console.error('Parameter type is not a number: ' + mode + ',' + numbeToken.text);\n                        return;\n                    }\n                }\n                if (typeof PARAMS[mode] === 'number') {\n                    const segment = { key: mode, data: params };\n                    this.segments.push(segment);\n                    index += param_length;\n                    token = tokens[index];\n                    if (mode === 'M')\n                        mode = 'L';\n                    if (mode === 'm')\n                        mode = 'l';\n                }\n                else {\n                    console.error('Unsupported segment type: ' + mode);\n                    return;\n                }\n            }\n            else {\n                console.error('Path data ended before all parameters were found');\n            }\n        }\n    }\n    get closed() {\n        if (typeof this._closed === 'undefined') {\n            this._closed = false;\n            for (const s of this.segments) {\n                if (s.key.toLowerCase() === 'z') {\n                    this._closed = true;\n                }\n            }\n        }\n        return this._closed;\n    }\n    processPoints() {\n        let first = null;\n        let currentPoint = [0, 0];\n        for (let i = 0; i < this.segments.length; i++) {\n            const s = this.segments[i];\n            switch (s.key) {\n                case 'M':\n                case 'L':\n                case 'T':\n                    s.point = [s.data[0], s.data[1]];\n                    break;\n                case 'm':\n                case 'l':\n                case 't':\n                    s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n                    break;\n                case 'H':\n                    s.point = [s.data[0], currentPoint[1]];\n                    break;\n                case 'h':\n                    s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n                    break;\n                case 'V':\n                    s.point = [currentPoint[0], s.data[0]];\n                    break;\n                case 'v':\n                    s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n                    break;\n                case 'z':\n                case 'Z':\n                    if (first) {\n                        s.point = [first[0], first[1]];\n                    }\n                    break;\n                case 'C':\n                    s.point = [s.data[4], s.data[5]];\n                    break;\n                case 'c':\n                    s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n                    break;\n                case 'S':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 's':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'Q':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 'q':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'A':\n                    s.point = [s.data[5], s.data[6]];\n                    break;\n                case 'a':\n                    s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n                    break;\n            }\n            if (s.key === 'm' || s.key === 'M') {\n                first = null;\n            }\n            if (s.point) {\n                currentPoint = s.point;\n                if (!first) {\n                    first = s.point;\n                }\n            }\n            if (s.key === 'z' || s.key === 'Z') {\n                first = null;\n            }\n        }\n    }\n}\nexport class RoughPath {\n    constructor(d) {\n        this._position = [0, 0];\n        this._first = null;\n        this.bezierReflectionPoint = null;\n        this.quadReflectionPoint = null;\n        this.parsed = new ParsedPath(d);\n    }\n    get segments() {\n        return this.parsed.segments;\n    }\n    get closed() {\n        return this.parsed.closed;\n    }\n    get linearPoints() {\n        if (!this._linearPoints) {\n            const lp = [];\n            let points = [];\n            for (const s of this.parsed.segments) {\n                const key = s.key.toLowerCase();\n                if (key === 'm' || key === 'z') {\n                    if (points.length) {\n                        lp.push(points);\n                        points = [];\n                    }\n                    if (key === 'z') {\n                        continue;\n                    }\n                }\n                if (s.point) {\n                    points.push(s.point);\n                }\n            }\n            if (points.length) {\n                lp.push(points);\n                points = [];\n            }\n            this._linearPoints = lp;\n        }\n        return this._linearPoints;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(v) {\n        this._first = v;\n    }\n    setPosition(x, y) {\n        this._position = [x, y];\n        if (!this._first) {\n            this._first = [x, y];\n        }\n    }\n    get position() {\n        return this._position;\n    }\n    get x() {\n        return this._position[0];\n    }\n    get y() {\n        return this._position[1];\n    }\n}\n// Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\nexport class RoughArcConverter {\n    constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n        this._segIndex = 0;\n        this._numSegs = 0;\n        this._rx = 0;\n        this._ry = 0;\n        this._sinPhi = 0;\n        this._cosPhi = 0;\n        this._C = [0, 0];\n        this._theta = 0;\n        this._delta = 0;\n        this._T = 0;\n        this._from = from;\n        if (from[0] === to[0] && from[1] === to[1]) {\n            return;\n        }\n        const radPerDeg = Math.PI / 180;\n        this._rx = Math.abs(radii[0]);\n        this._ry = Math.abs(radii[1]);\n        this._sinPhi = Math.sin(angle * radPerDeg);\n        this._cosPhi = Math.cos(angle * radPerDeg);\n        const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n        const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n        let root = 0;\n        const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n        if (numerator < 0) {\n            const s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n            this._rx = this._rx * s;\n            this._ry = this._ry * s;\n            root = 0;\n        }\n        else {\n            root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) *\n                Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n        }\n        const cxdash = root * this._rx * y1dash / this._ry;\n        const cydash = -root * this._ry * x1dash / this._rx;\n        this._C = [0, 0];\n        this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n        this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n        this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n        let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n        if ((!sweepFlag) && (dtheta > 0)) {\n            dtheta -= 2 * Math.PI;\n        }\n        else if (sweepFlag && (dtheta < 0)) {\n            dtheta += 2 * Math.PI;\n        }\n        this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n        this._delta = dtheta / this._numSegs;\n        this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    }\n    getNextSegment() {\n        if (this._segIndex === this._numSegs) {\n            return null;\n        }\n        const cosTheta1 = Math.cos(this._theta);\n        const sinTheta1 = Math.sin(this._theta);\n        const theta2 = this._theta + this._delta;\n        const cosTheta2 = Math.cos(theta2);\n        const sinTheta2 = Math.sin(theta2);\n        const to = [\n            this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n            this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n        ];\n        const cp1 = [\n            this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n            this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n        ];\n        const cp2 = [\n            to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n            to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n        ];\n        this._theta = theta2;\n        this._from = [to[0], to[1]];\n        this._segIndex++;\n        return {\n            cp1: cp1,\n            cp2: cp2,\n            to: to\n        };\n    }\n    calculateVectorAngle(ux, uy, vx, vy) {\n        const ta = Math.atan2(uy, ux);\n        const tb = Math.atan2(vy, vx);\n        if (tb >= ta)\n            return tb - ta;\n        return 2 * Math.PI - (ta - tb);\n    }\n}\nexport class PathFitter {\n    constructor(sets, closed) {\n        this.sets = sets;\n        this.closed = closed;\n    }\n    fit(simplification) {\n        const outSets = [];\n        for (const set of this.sets) {\n            const length = set.length;\n            let estLength = Math.floor(simplification * length);\n            if (estLength < 5) {\n                if (length <= 5) {\n                    continue;\n                }\n                estLength = 5;\n            }\n            outSets.push(this.reduce(set, estLength));\n        }\n        let d = '';\n        for (const set of outSets) {\n            for (let i = 0; i < set.length; i++) {\n                const point = set[i];\n                if (i === 0) {\n                    d += 'M' + point[0] + ',' + point[1];\n                }\n                else {\n                    d += 'L' + point[0] + ',' + point[1];\n                }\n            }\n            if (this.closed) {\n                d += 'z ';\n            }\n        }\n        return d;\n    }\n    distance(p1, p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n    reduce(set, count) {\n        if (set.length <= count) {\n            return set;\n        }\n        const points = set.slice(0);\n        while (points.length > count) {\n            const areas = [];\n            let minArea = -1;\n            let minIndex = -1;\n            for (let i = 1; i < (points.length - 1); i++) {\n                const a = this.distance(points[i - 1], points[i]);\n                const b = this.distance(points[i], points[i + 1]);\n                const c = this.distance(points[i - 1], points[i + 1]);\n                const s = (a + b + c) / 2.0;\n                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n                areas.push(area);\n                if ((minArea < 0) || (area < minArea)) {\n                    minArea = area;\n                    minIndex = i;\n                }\n            }\n            if (minIndex > 0) {\n                points.splice(minIndex, 1);\n            }\n            else {\n                break;\n            }\n        }\n        return points;\n    }\n}\n","export class Segment {\n    constructor(p1, p2) {\n        this.xi = Number.MAX_VALUE;\n        this.yi = Number.MAX_VALUE;\n        this.px1 = p1[0];\n        this.py1 = p1[1];\n        this.px2 = p2[0];\n        this.py2 = p2[1];\n        this.a = this.py2 - this.py1;\n        this.b = this.px1 - this.px2;\n        this.c = this.px2 * this.py1 - this.px1 * this.py2;\n        this._undefined = ((this.a === 0) && (this.b === 0) && (this.c === 0));\n    }\n    isUndefined() {\n        return this._undefined;\n    }\n    intersects(otherSegment) {\n        if (this.isUndefined() || otherSegment.isUndefined()) {\n            return false;\n        }\n        let grad1 = Number.MAX_VALUE;\n        let grad2 = Number.MAX_VALUE;\n        let int1 = 0, int2 = 0;\n        const a = this.a, b = this.b, c = this.c;\n        if (Math.abs(b) > 0.00001) {\n            grad1 = -a / b;\n            int1 = -c / b;\n        }\n        if (Math.abs(otherSegment.b) > 0.00001) {\n            grad2 = -otherSegment.a / otherSegment.b;\n            int2 = -otherSegment.c / otherSegment.b;\n        }\n        if (grad1 === Number.MAX_VALUE) {\n            if (grad2 === Number.MAX_VALUE) {\n                if ((-c / a) !== (-otherSegment.c / otherSegment.a)) {\n                    return false;\n                }\n                if ((this.py1 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px1;\n                    this.yi = this.py1;\n                    return true;\n                }\n                if ((this.py2 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py2 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                    this.xi = this.px2;\n                    this.yi = this.py2;\n                    return true;\n                }\n                return false;\n            }\n            this.xi = this.px1;\n            this.yi = (grad2 * this.xi + int2);\n            if (((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) || ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(otherSegment.a) < 0.00001) {\n                if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad2 === Number.MAX_VALUE) {\n            this.xi = otherSegment.px1;\n            this.yi = grad1 * this.xi + int1;\n            if (((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) || ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001)) {\n                return false;\n            }\n            if (Math.abs(a) < 0.00001) {\n                if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n                    return false;\n                }\n                return true;\n            }\n            return true;\n        }\n        if (grad1 === grad2) {\n            if (int1 !== int2) {\n                return false;\n            }\n            if ((this.px1 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n                this.xi = this.px1;\n                this.yi = this.py1;\n                return true;\n            }\n            if ((this.px2 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px2 <= Math.max(otherSegment.px1, otherSegment.px2))) {\n                this.xi = this.px2;\n                this.yi = this.py2;\n                return true;\n            }\n            return false;\n        }\n        this.xi = ((int2 - int1) / (grad1 - grad2));\n        this.yi = (grad1 * this.xi + int1);\n        if (((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) || ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001)) {\n            return false;\n        }\n        return true;\n    }\n}\n","import { Segment } from '../geometry';\nexport class HachureIterator {\n    constructor(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {\n        this.deltaX = 0;\n        this.hGap = 0;\n        this.top = top;\n        this.bottom = bottom;\n        this.left = left;\n        this.right = right;\n        this.gap = gap;\n        this.sinAngle = sinAngle;\n        this.tanAngle = tanAngle;\n        if (Math.abs(sinAngle) < 0.0001) {\n            this.pos = left + gap;\n        }\n        else if (Math.abs(sinAngle) > 0.9999) {\n            this.pos = top + gap;\n        }\n        else {\n            this.deltaX = (bottom - top) * Math.abs(tanAngle);\n            this.pos = left - Math.abs(this.deltaX);\n            this.hGap = Math.abs(gap / cosAngle);\n            this.sLeft = new Segment([left, bottom], [left, top]);\n            this.sRight = new Segment([right, bottom], [right, top]);\n        }\n    }\n    nextLine() {\n        if (Math.abs(this.sinAngle) < 0.0001) {\n            if (this.pos < this.right) {\n                const line = [this.pos, this.top, this.pos, this.bottom];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else if (Math.abs(this.sinAngle) > 0.9999) {\n            if (this.pos < this.bottom) {\n                const line = [this.left, this.pos, this.right, this.pos];\n                this.pos += this.gap;\n                return line;\n            }\n        }\n        else {\n            let xLower = this.pos - this.deltaX / 2;\n            let xUpper = this.pos + this.deltaX / 2;\n            let yLower = this.bottom;\n            let yUpper = this.top;\n            if (this.pos < (this.right + this.deltaX)) {\n                while (((xLower < this.left) && (xUpper < this.left)) || ((xLower > this.right) && (xUpper > this.right))) {\n                    this.pos += this.hGap;\n                    xLower = this.pos - this.deltaX / 2;\n                    xUpper = this.pos + this.deltaX / 2;\n                    if (this.pos > (this.right + this.deltaX)) {\n                        return null;\n                    }\n                }\n                const s = new Segment([xLower, yLower], [xUpper, yUpper]);\n                if (this.sLeft && s.intersects(this.sLeft)) {\n                    xLower = s.xi;\n                    yLower = s.yi;\n                }\n                if (this.sRight && s.intersects(this.sRight)) {\n                    xUpper = s.xi;\n                    yUpper = s.yi;\n                }\n                if (this.tanAngle > 0) {\n                    xLower = this.right - (xLower - this.left);\n                    xUpper = this.right - (xUpper - this.left);\n                }\n                const line = [xLower, yLower, xUpper, yUpper];\n                this.pos += this.hGap;\n                return line;\n            }\n        }\n        return null;\n    }\n}\n","import { Segment } from '../geometry';\nimport { HachureIterator } from '../utils/hachure';\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getIntersectingLines(line, points) {\n    const intersections = [];\n    const s1 = new Segment([line[0], line[1]], [line[2], line[3]]);\n    for (let i = 0; i < points.length; i++) {\n        const s2 = new Segment(points[i], points[(i + 1) % points.length]);\n        if (s1.intersects(s2)) {\n            intersections.push([s1.xi, s1.yi]);\n        }\n    }\n    return intersections;\n}\nexport function affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n    const A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n    const B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n    const C = cosAnglePrime;\n    const D = sinAnglePrime;\n    const E = -R * sinAnglePrime;\n    const F = R * cosAnglePrime;\n    return [\n        A + C * x + D * y,\n        B + E * x + F * y\n    ];\n}\nexport function hachureLinesForPolygon(points, o) {\n    const ret = [];\n    if (points && points.length) {\n        let left = points[0][0];\n        let right = points[0][0];\n        let top = points[0][1];\n        let bottom = points[0][1];\n        for (let i = 1; i < points.length; i++) {\n            left = Math.min(left, points[i][0]);\n            right = Math.max(right, points[i][0]);\n            top = Math.min(top, points[i][1]);\n            bottom = Math.max(bottom, points[i][1]);\n        }\n        const angle = o.hachureAngle;\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const radPerDeg = Math.PI / 180;\n        const hachureAngle = (angle % 180) * radPerDeg;\n        const cosAngle = Math.cos(hachureAngle);\n        const sinAngle = Math.sin(hachureAngle);\n        const tanAngle = Math.tan(hachureAngle);\n        const it = new HachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n        let rect;\n        while ((rect = it.nextLine()) != null) {\n            const lines = getIntersectingLines(rect, points);\n            for (let i = 0; i < lines.length; i++) {\n                if (i < (lines.length - 1)) {\n                    const p1 = lines[i];\n                    const p2 = lines[i + 1];\n                    ret.push([p1, p2]);\n                }\n            }\n        }\n    }\n    return ret;\n}\nexport function hachureLinesForEllipse(cx, cy, width, height, o, renderer) {\n    const ret = [];\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += renderer.getOffset(-rx * 0.05, rx * 0.05, o);\n    ry += renderer.getOffset(-ry * 0.05, ry * 0.05, o);\n    const angle = o.hachureAngle;\n    let gap = o.hachureGap;\n    if (gap <= 0) {\n        gap = o.strokeWidth * 4;\n    }\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n    }\n    const radPerDeg = Math.PI / 180;\n    const hachureAngle = (angle % 180) * radPerDeg;\n    const tanAngle = Math.tan(hachureAngle);\n    const aspectRatio = ry / rx;\n    const hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n    const sinAnglePrime = aspectRatio * tanAngle / hyp;\n    const cosAnglePrime = 1 / hyp;\n    const gapPrime = gap / ((rx * ry / Math.sqrt((ry * cosAnglePrime) * (ry * cosAnglePrime) + (rx * sinAnglePrime) * (rx * sinAnglePrime))) / rx);\n    let halfLen = Math.sqrt((rx * rx) - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n    for (let xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n        halfLen = Math.sqrt((rx * rx) - (cx - xPos) * (cx - xPos));\n        const p1 = affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        const p2 = affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n        ret.push([p1, p2]);\n    }\n    return ret;\n}\n","import { hachureLinesForPolygon, hachureLinesForEllipse } from './filler-utils';\nexport class HachureFiller {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        return this._fillEllipse(cx, cy, width, height, o);\n    }\n    _fillPolygon(points, o, connectEnds = false) {\n        const lines = hachureLinesForPolygon(points, o);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    _fillEllipse(cx, cy, width, height, o, connectEnds = false) {\n        const lines = hachureLinesForEllipse(cx, cy, width, height, o, this.renderer);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o, connectEnds) {\n        let ops = [];\n        let prevPoint = null;\n        for (const line of lines) {\n            ops = ops.concat(this.renderer.doubleLine(line[0][0], line[0][1], line[1][0], line[1][1], o));\n            if (connectEnds && prevPoint) {\n                ops = ops.concat(this.renderer.doubleLine(prevPoint[0], prevPoint[1], line[0][0], line[0][1], o));\n            }\n            prevPoint = line[1];\n        }\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o, true);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        return this._fillEllipse(cx, cy, width, height, o, true);\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        const set = this._fillPolygon(points, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygon(points, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        const set = this._fillEllipse(cx, cy, width, height, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillEllipse(cx, cy, width, height, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n","import { hachureLinesForPolygon, hachureLinesForEllipse, lineLength } from './filler-utils';\nexport class DotFiller {\n    constructor(renderer) {\n        this.renderer = renderer;\n    }\n    fillPolygon(points, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0 });\n        const lines = hachureLinesForPolygon(points, o);\n        return this.dotsOnLines(lines, o);\n    }\n    fillEllipse(cx, cy, width, height, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0 });\n        const lines = hachureLinesForEllipse(cx, cy, width, height, o, this.renderer);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        let ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const alpha = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));\n            for (let i = 0; i < count; i++) {\n                const l = gap * (i + 1);\n                const dy = l * Math.sin(alpha);\n                const dx = l * Math.cos(alpha);\n                const c = [line[0][0] - dx, line[0][1] + dy];\n                const cx = this.renderer.getOffset(c[0] - gap / 4, c[0] + gap / 4, o);\n                const cy = this.renderer.getOffset(c[1] - gap / 4, c[1] + gap / 4, o);\n                const ellipse = this.renderer.ellipse(cx, cy, fweight, fweight, o);\n                ops = ops.concat(ellipse.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nconst fillers = {};\nexport function getFiller(renderer, o) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(renderer);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(renderer);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(renderer);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(renderer);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n","import { RoughPath, RoughArcConverter, PathFitter } from './path.js';\nimport { getFiller } from './fillers/filler';\nexport class RoughRenderer {\n    line(x1, y1, x2, y2, o) {\n        const ops = this.doubleLine(x1, y1, x2, y2, o);\n        return { type: 'path', ops };\n    }\n    linearPath(points, close, o) {\n        const len = (points || []).length;\n        if (len > 2) {\n            let ops = [];\n            for (let i = 0; i < (len - 1); i++) {\n                ops = ops.concat(this.doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n            }\n            if (close) {\n                ops = ops.concat(this.doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n            }\n            return { type: 'path', ops };\n        }\n        else if (len === 2) {\n            return this.line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n        }\n        return { type: 'path', ops: [] };\n    }\n    polygon(points, o) {\n        return this.linearPath(points, true, o);\n    }\n    rectangle(x, y, width, height, o) {\n        const points = [\n            [x, y], [x + width, y], [x + width, y + height], [x, y + height]\n        ];\n        return this.polygon(points, o);\n    }\n    curve(points, o) {\n        const o1 = this._curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n        const o2 = this._curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    ellipse(x, y, width, height, o) {\n        const increment = (Math.PI * 2) / o.curveStepCount;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.05, rx * 0.05, o);\n        ry += this.getOffset(-ry * 0.05, ry * 0.05, o);\n        const o1 = this._ellipse(increment, x, y, rx, ry, 1, increment * this.getOffset(0.1, this.getOffset(0.4, 1, o), o), o);\n        const o2 = this._ellipse(increment, x, y, rx, ry, 1.5, 0, o);\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n        const cx = x;\n        const cy = y;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.01, rx * 0.01, o);\n        ry += this.getOffset(-ry * 0.01, ry * 0.01, o);\n        let strt = start;\n        let stp = stop;\n        while (strt < 0) {\n            strt += Math.PI * 2;\n            stp += Math.PI * 2;\n        }\n        if ((stp - strt) > (Math.PI * 2)) {\n            strt = 0;\n            stp = Math.PI * 2;\n        }\n        const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n        const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n        const o1 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n        const o2 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        let ops = o1.concat(o2);\n        if (closed) {\n            if (roughClosure) {\n                ops = ops.concat(this.doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n                ops = ops.concat(this.doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n            }\n            else {\n                ops.push({ op: 'lineTo', data: [cx, cy] });\n                ops.push({ op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n            }\n        }\n        return { type: 'path', ops };\n    }\n    svgPath(path, o) {\n        path = (path || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        let p = new RoughPath(path);\n        if (o.simplification) {\n            const fitter = new PathFitter(p.linearPoints, p.closed);\n            const d = fitter.fit(o.simplification);\n            p = new RoughPath(d);\n        }\n        let ops = [];\n        const segments = p.segments || [];\n        for (let i = 0; i < segments.length; i++) {\n            const s = segments[i];\n            const prev = i > 0 ? segments[i - 1] : null;\n            const opList = this._processSegment(p, s, prev, o);\n            if (opList && opList.length) {\n                ops = ops.concat(opList);\n            }\n        }\n        return { type: 'path', ops };\n    }\n    solidFillPolygon(points, o) {\n        const ops = [];\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + this.getOffset(-offset, offset, o), points[0][1] + this.getOffset(-offset, offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + this.getOffset(-offset, offset, o), points[i][1] + this.getOffset(-offset, offset, o)] });\n                }\n            }\n        }\n        return { type: 'fillPath', ops };\n    }\n    patternFillPolygon(points, o) {\n        const filler = getFiller(this, o);\n        return filler.fillPolygon(points, o);\n    }\n    patternFillEllipse(cx, cy, width, height, o) {\n        const filler = getFiller(this, o);\n        return filler.fillEllipse(cx, cy, width, height, o);\n    }\n    patternFillArc(x, y, width, height, start, stop, o) {\n        const cx = x;\n        const cy = y;\n        let rx = Math.abs(width / 2);\n        let ry = Math.abs(height / 2);\n        rx += this.getOffset(-rx * 0.01, rx * 0.01, o);\n        ry += this.getOffset(-ry * 0.01, ry * 0.01, o);\n        let strt = start;\n        let stp = stop;\n        while (strt < 0) {\n            strt += Math.PI * 2;\n            stp += Math.PI * 2;\n        }\n        if ((stp - strt) > (Math.PI * 2)) {\n            strt = 0;\n            stp = Math.PI * 2;\n        }\n        const increment = (stp - strt) / o.curveStepCount;\n        const points = [];\n        for (let angle = strt; angle <= stp; angle = angle + increment) {\n            points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n        }\n        points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n        points.push([cx, cy]);\n        return this.patternFillPolygon(points, o);\n    }\n    /// \n    getOffset(min, max, ops) {\n        return ops.roughness * ((Math.random() * (max - min)) + min);\n    }\n    doubleLine(x1, y1, x2, y2, o) {\n        const o1 = this._line(x1, y1, x2, y2, o, true, false);\n        const o2 = this._line(x1, y1, x2, y2, o, true, true);\n        return o1.concat(o2);\n    }\n    _line(x1, y1, x2, y2, o, move, overlay) {\n        const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n        let offset = o.maxRandomnessOffset || 0;\n        if ((offset * offset * 100) > lengthSq) {\n            offset = Math.sqrt(lengthSq) / 10;\n        }\n        const halfOffset = offset / 2;\n        const divergePoint = 0.2 + Math.random() * 0.2;\n        let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n        let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n        midDispX = this.getOffset(-midDispX, midDispX, o);\n        midDispY = this.getOffset(-midDispY, midDispY, o);\n        const ops = [];\n        if (move) {\n            if (overlay) {\n                ops.push({\n                    op: 'move', data: [\n                        x1 + this.getOffset(-halfOffset, halfOffset, o),\n                        y1 + this.getOffset(-halfOffset, halfOffset, o)\n                    ]\n                });\n            }\n            else {\n                ops.push({\n                    op: 'move', data: [\n                        x1 + this.getOffset(-offset, offset, o),\n                        y1 + this.getOffset(-offset, offset, o)\n                    ]\n                });\n            }\n        }\n        if (overlay) {\n            ops.push({\n                op: 'bcurveTo', data: [\n                    midDispX + x1 + (x2 - x1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispY + y1 + (y2 - y1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispX + x1 + 2 * (x2 - x1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    midDispY + y1 + 2 * (y2 - y1) * divergePoint + this.getOffset(-halfOffset, halfOffset, o),\n                    x2 + this.getOffset(-halfOffset, halfOffset, o),\n                    y2 + this.getOffset(-halfOffset, halfOffset, o)\n                ]\n            });\n        }\n        else {\n            ops.push({\n                op: 'bcurveTo', data: [\n                    midDispX + x1 + (x2 - x1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispY + y1 + (y2 - y1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispX + x1 + 2 * (x2 - x1) * divergePoint + this.getOffset(-offset, offset, o),\n                    midDispY + y1 + 2 * (y2 - y1) * divergePoint + this.getOffset(-offset, offset, o),\n                    x2 + this.getOffset(-offset, offset, o),\n                    y2 + this.getOffset(-offset, offset, o)\n                ]\n            });\n        }\n        return ops;\n    }\n    _curve(points, closePoint, o) {\n        const len = points.length;\n        let ops = [];\n        if (len > 3) {\n            const b = [];\n            const s = 1 - o.curveTightness;\n            ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n            for (let i = 1; (i + 2) < len; i++) {\n                const cachedVertArray = points[i];\n                b[0] = [cachedVertArray[0], cachedVertArray[1]];\n                b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n                b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n                b[3] = [points[i + 1][0], points[i + 1][1]];\n                ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n            }\n            if (closePoint && closePoint.length === 2) {\n                const ro = o.maxRandomnessOffset;\n                ops.push({ op: 'lineTo', data: [closePoint[0] + this.getOffset(-ro, ro, o), closePoint[1] + +this.getOffset(-ro, ro, o)] });\n            }\n        }\n        else if (len === 3) {\n            ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n            ops.push({\n                op: 'bcurveTo', data: [\n                    points[1][0], points[1][1],\n                    points[2][0], points[2][1],\n                    points[2][0], points[2][1]\n                ]\n            });\n        }\n        else if (len === 2) {\n            ops = ops.concat(this.doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n        }\n        return ops;\n    }\n    _ellipse(increment, cx, cy, rx, ry, offset, overlap, o) {\n        const radOffset = this.getOffset(-0.5, 0.5, o) - (Math.PI / 2);\n        const points = [];\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n        ]);\n        for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n            points.push([\n                this.getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n                this.getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n            ]);\n        }\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            this.getOffset(-offset, offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n        ]);\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            this.getOffset(-offset, offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n        ]);\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n        ]);\n        return this._curve(points, null, o);\n    }\n    _curveWithOffset(points, offset, o) {\n        const ps = [];\n        ps.push([\n            points[0][0] + this.getOffset(-offset, offset, o),\n            points[0][1] + this.getOffset(-offset, offset, o),\n        ]);\n        ps.push([\n            points[0][0] + this.getOffset(-offset, offset, o),\n            points[0][1] + this.getOffset(-offset, offset, o),\n        ]);\n        for (let i = 1; i < points.length; i++) {\n            ps.push([\n                points[i][0] + this.getOffset(-offset, offset, o),\n                points[i][1] + this.getOffset(-offset, offset, o),\n            ]);\n            if (i === (points.length - 1)) {\n                ps.push([\n                    points[i][0] + this.getOffset(-offset, offset, o),\n                    points[i][1] + this.getOffset(-offset, offset, o),\n                ]);\n            }\n        }\n        return this._curve(ps, null, o);\n    }\n    _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n        const radOffset = strt + this.getOffset(-0.1, 0.1, o);\n        const points = [];\n        points.push([\n            this.getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            this.getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n        ]);\n        for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n            points.push([\n                this.getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n                this.getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n            ]);\n        }\n        points.push([\n            cx + rx * Math.cos(stp),\n            cy + ry * Math.sin(stp)\n        ]);\n        points.push([\n            cx + rx * Math.cos(stp),\n            cy + ry * Math.sin(stp)\n        ]);\n        return this._curve(points, null, o);\n    }\n    _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n        const ops = [];\n        const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n        let f = [0, 0];\n        for (let i = 0; i < 2; i++) {\n            if (i === 0) {\n                ops.push({ op: 'move', data: [path.x, path.y] });\n            }\n            else {\n                ops.push({ op: 'move', data: [path.x + this.getOffset(-ros[0], ros[0], o), path.y + this.getOffset(-ros[0], ros[0], o)] });\n            }\n            f = [x + this.getOffset(-ros[i], ros[i], o), y + this.getOffset(-ros[i], ros[i], o)];\n            ops.push({\n                op: 'bcurveTo', data: [\n                    x1 + this.getOffset(-ros[i], ros[i], o), y1 + this.getOffset(-ros[i], ros[i], o),\n                    x2 + this.getOffset(-ros[i], ros[i], o), y2 + this.getOffset(-ros[i], ros[i], o),\n                    f[0], f[1]\n                ]\n            });\n        }\n        path.setPosition(f[0], f[1]);\n        return ops;\n    }\n    _processSegment(path, seg, prevSeg, o) {\n        let ops = [];\n        switch (seg.key) {\n            case 'M':\n            case 'm': {\n                const delta = seg.key === 'm';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    const ro = 1 * (o.maxRandomnessOffset || 0);\n                    x = x + this.getOffset(-ro, ro, o);\n                    y = y + this.getOffset(-ro, ro, o);\n                    path.setPosition(x, y);\n                    ops.push({ op: 'move', data: [x, y] });\n                }\n                break;\n            }\n            case 'L':\n            case 'l': {\n                const delta = seg.key === 'l';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, x, y, o));\n                    path.setPosition(x, y);\n                }\n                break;\n            }\n            case 'H':\n            case 'h': {\n                const delta = seg.key === 'h';\n                if (seg.data.length) {\n                    let x = +seg.data[0];\n                    if (delta) {\n                        x += path.x;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, x, path.y, o));\n                    path.setPosition(x, path.y);\n                }\n                break;\n            }\n            case 'V':\n            case 'v': {\n                const delta = seg.key === 'v';\n                if (seg.data.length) {\n                    let y = +seg.data[0];\n                    if (delta) {\n                        y += path.y;\n                    }\n                    ops = ops.concat(this.doubleLine(path.x, path.y, path.x, y, o));\n                    path.setPosition(path.x, y);\n                }\n                break;\n            }\n            case 'Z':\n            case 'z': {\n                if (path.first) {\n                    ops = ops.concat(this.doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n                    path.setPosition(path.first[0], path.first[1]);\n                    path.first = null;\n                }\n                break;\n            }\n            case 'C':\n            case 'c': {\n                const delta = seg.key === 'c';\n                if (seg.data.length >= 6) {\n                    let x1 = +seg.data[0];\n                    let y1 = +seg.data[1];\n                    let x2 = +seg.data[2];\n                    let y2 = +seg.data[3];\n                    let x = +seg.data[4];\n                    let y = +seg.data[5];\n                    if (delta) {\n                        x1 += path.x;\n                        x2 += path.x;\n                        x += path.x;\n                        y1 += path.y;\n                        y2 += path.y;\n                        y += path.y;\n                    }\n                    const ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n                    ops = ops.concat(ob);\n                    path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n                }\n                break;\n            }\n            case 'S':\n            case 's': {\n                const delta = seg.key === 's';\n                if (seg.data.length >= 4) {\n                    let x2 = +seg.data[0];\n                    let y2 = +seg.data[1];\n                    let x = +seg.data[2];\n                    let y = +seg.data[3];\n                    if (delta) {\n                        x2 += path.x;\n                        x += path.x;\n                        y2 += path.y;\n                        y += path.y;\n                    }\n                    let x1 = x2;\n                    let y1 = y2;\n                    const prevKey = prevSeg ? prevSeg.key : '';\n                    let ref = null;\n                    if (prevKey === 'c' || prevKey === 'C' || prevKey === 's' || prevKey === 'S') {\n                        ref = path.bezierReflectionPoint;\n                    }\n                    if (ref) {\n                        x1 = ref[0];\n                        y1 = ref[1];\n                    }\n                    const ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n                    ops = ops.concat(ob);\n                    path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n                }\n                break;\n            }\n            case 'Q':\n            case 'q': {\n                const delta = seg.key === 'q';\n                if (seg.data.length >= 4) {\n                    let x1 = +seg.data[0];\n                    let y1 = +seg.data[1];\n                    let x = +seg.data[2];\n                    let y = +seg.data[3];\n                    if (delta) {\n                        x1 += path.x;\n                        x += path.x;\n                        y1 += path.y;\n                        y += path.y;\n                    }\n                    const offset1 = 1 * (1 + o.roughness * 0.2);\n                    const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset1, offset1, o), path.y + this.getOffset(-offset1, offset1, o)] });\n                    let f = [x + this.getOffset(-offset1, offset1, o), y + this.getOffset(-offset1, offset1, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset1, offset1, o), y1 + this.getOffset(-offset1, offset1, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset2, offset2, o), path.y + this.getOffset(-offset2, offset2, o)] });\n                    f = [x + this.getOffset(-offset2, offset2, o), y + this.getOffset(-offset2, offset2, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset2, offset2, o), y1 + this.getOffset(-offset2, offset2, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    path.setPosition(f[0], f[1]);\n                    path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n                }\n                break;\n            }\n            case 'T':\n            case 't': {\n                const delta = seg.key === 't';\n                if (seg.data.length >= 2) {\n                    let x = +seg.data[0];\n                    let y = +seg.data[1];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    let x1 = x;\n                    let y1 = y;\n                    const prevKey = prevSeg ? prevSeg.key : '';\n                    let ref = null;\n                    if (prevKey === 'q' || prevKey === 'Q' || prevKey === 't' || prevKey === 'T') {\n                        ref = path.quadReflectionPoint;\n                    }\n                    if (ref) {\n                        x1 = ref[0];\n                        y1 = ref[1];\n                    }\n                    const offset1 = 1 * (1 + o.roughness * 0.2);\n                    const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset1, offset1, o), path.y + this.getOffset(-offset1, offset1, o)] });\n                    let f = [x + this.getOffset(-offset1, offset1, o), y + this.getOffset(-offset1, offset1, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset1, offset1, o), y1 + this.getOffset(-offset1, offset1, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    ops.push({ op: 'move', data: [path.x + this.getOffset(-offset2, offset2, o), path.y + this.getOffset(-offset2, offset2, o)] });\n                    f = [x + this.getOffset(-offset2, offset2, o), y + this.getOffset(-offset2, offset2, o)];\n                    ops.push({\n                        op: 'qcurveTo', data: [\n                            x1 + this.getOffset(-offset2, offset2, o), y1 + this.getOffset(-offset2, offset2, o),\n                            f[0], f[1]\n                        ]\n                    });\n                    path.setPosition(f[0], f[1]);\n                    path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n                }\n                break;\n            }\n            case 'A':\n            case 'a': {\n                const delta = seg.key === 'a';\n                if (seg.data.length >= 7) {\n                    const rx = +seg.data[0];\n                    const ry = +seg.data[1];\n                    const angle = +seg.data[2];\n                    const largeArcFlag = +seg.data[3];\n                    const sweepFlag = +seg.data[4];\n                    let x = +seg.data[5];\n                    let y = +seg.data[6];\n                    if (delta) {\n                        x += path.x;\n                        y += path.y;\n                    }\n                    if (x === path.x && y === path.y) {\n                        break;\n                    }\n                    if (rx === 0 || ry === 0) {\n                        ops = ops.concat(this.doubleLine(path.x, path.y, x, y, o));\n                        path.setPosition(x, y);\n                    }\n                    else {\n                        for (let i = 0; i < 1; i++) {\n                            const arcConverter = new RoughArcConverter([path.x, path.y], [x, y], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);\n                            let segment = arcConverter.getNextSegment();\n                            while (segment) {\n                                const ob = this._bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n                                ops = ops.concat(ob);\n                                segment = arcConverter.getNextSegment();\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n            default:\n                break;\n        }\n        return ops;\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasSelf = typeof self !== 'undefined';\nconst roughScript = hasSelf && self && self.document && self.document.currentScript && self.document.currentScript.src;\nexport function createRenderer(config) {\n    if (hasSelf && roughScript && self && self.workly && config.async && (!config.noWorker)) {\n        const worklySource = config.worklyURL || 'https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js';\n        if (worklySource) {\n            const code = `importScripts('${worklySource}', '${roughScript}');\\nworkly.expose(self.rough.createRenderer());`;\n            const ourl = URL.createObjectURL(new Blob([code]));\n            return self.workly.proxy(ourl);\n        }\n    }\n    return new RoughRenderer();\n}\n","import { createRenderer } from './renderer-factory.js';\nconst hasSelf = typeof self !== 'undefined';\nexport class RoughGeneratorBase {\n    constructor(config, surface) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1\n        };\n        this.config = config || {};\n        this.surface = surface;\n        this.renderer = createRenderer(this.config);\n        if (this.config.options) {\n            this.defaultOptions = this._options(this.config.options);\n        }\n    }\n    _options(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _drawable(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    get lib() {\n        return this.renderer;\n    }\n    getCanvasSize() {\n        const val = (w) => {\n            if (w && typeof w === 'object') {\n                if (w.baseVal && w.baseVal.value) {\n                    return w.baseVal.value;\n                }\n            }\n            return w || 100;\n        };\n        if (this.surface) {\n            return [val(this.surface.width), val(this.surface.height)];\n        }\n        return [100, 100];\n    }\n    computePolygonSize(points) {\n        if (points.length) {\n            let left = points[0][0];\n            let right = points[0][0];\n            let top = points[0][1];\n            let bottom = points[0][1];\n            for (let i = 1; i < points.length; i++) {\n                left = Math.min(left, points[i][0]);\n                right = Math.max(right, points[i][0]);\n                top = Math.min(top, points[i][1]);\n                bottom = Math.max(bottom, points[i][1]);\n            }\n            return [(right - left), (bottom - top)];\n        }\n        return [0, 0];\n    }\n    polygonPath(points) {\n        let d = '';\n        if (points.length) {\n            d = `M${points[0][0]},${points[0][1]}`;\n            for (let i = 1; i < points.length; i++) {\n                d = `${d} L${points[i][0]},${points[i][1]}`;\n            }\n        }\n        return d;\n    }\n    computePathSize(d) {\n        let size = [0, 0];\n        if (hasSelf && self.document) {\n            try {\n                const ns = 'http://www.w3.org/2000/svg';\n                const svg = self.document.createElementNS(ns, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(ns, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                self.document.body.appendChild(svg);\n                const bb = pathNode.getBBox();\n                if (bb) {\n                    size[0] = bb.width || 0;\n                    size[1] = bb.height || 0;\n                }\n                self.document.body.removeChild(svg);\n            }\n            catch (err) { }\n        }\n        const canvasSize = this.getCanvasSize();\n        if (!(size[0] * size[1])) {\n            size = canvasSize;\n        }\n        return size;\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: 'none'\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        fill: o.fill || 'none'\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n                case 'path2Dfill':\n                    path = {\n                        d: drawing.path || '',\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        fill: o.fill || 'none'\n                    };\n                    break;\n                case 'path2Dpattern': {\n                    const size = drawing.size;\n                    const pattern = {\n                        x: 0, y: 0, width: 1, height: 1,\n                        viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n                        patternUnits: 'objectBoundingBox',\n                        path: this.fillSketch(drawing, o)\n                    };\n                    path = {\n                        d: drawing.path,\n                        stroke: 'none',\n                        strokeWidth: 0,\n                        pattern: pattern\n                    };\n                    break;\n                }\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || 'none',\n            strokeWidth: fweight,\n            fill: 'none'\n        };\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'qcurveTo':\n                    path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n}\n","import { RoughGeneratorBase } from './generator-base';\nexport class RoughGenerator extends RoughGeneratorBase {\n    constructor(config, surface) {\n        super(config, surface);\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [this.lib.line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(this.lib.patternFillPolygon(points, o));\n            }\n        }\n        paths.push(this.lib.rectangle(x, y, width, height, o));\n        return this._drawable('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = this.lib.ellipse(x, y, width, height, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(this.lib.patternFillEllipse(x, y, width, height, o));\n            }\n        }\n        paths.push(this.lib.ellipse(x, y, width, height, o));\n        return this._drawable('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [this.lib.linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = this.lib.arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(this.lib.patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        paths.push(this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n        return this._drawable('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [this.lib.curve(points, o)], o);\n    }\n    polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                const size = this.computePolygonSize(points);\n                const fillPoints = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = this.lib.patternFillPolygon(fillPoints, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = this.polygonPath(points);\n                paths.push(shape);\n            }\n        }\n        paths.push(this.lib.linearPath(points, true, o));\n        return this._drawable('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = this.lib.patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        paths.push(this.lib.svgPath(d, o));\n        return this._drawable('path', paths, o);\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvasBase {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n    }\n    static createRenderer() {\n        return new RoughRenderer();\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n                case 'path2Dfill': {\n                    this.ctx.save();\n                    this.ctx.fillStyle = o.fill || '';\n                    const p2d = new Path2D(drawing.path);\n                    this.ctx.fill(p2d);\n                    this.ctx.restore();\n                    break;\n                }\n                case 'path2Dpattern': {\n                    const doc = this.canvas.ownerDocument || (hasDocument && document);\n                    if (doc) {\n                        const size = drawing.size;\n                        const hcanvas = doc.createElement('canvas');\n                        const hcontext = hcanvas.getContext('2d');\n                        const bbox = this.computeBBox(drawing.path);\n                        if (bbox && (bbox.width || bbox.height)) {\n                            hcanvas.width = this.canvas.width;\n                            hcanvas.height = this.canvas.height;\n                            hcontext.translate(bbox.x || 0, bbox.y || 0);\n                        }\n                        else {\n                            hcanvas.width = size[0];\n                            hcanvas.height = size[1];\n                        }\n                        this.fillSketch(hcontext, drawing, o);\n                        this.ctx.save();\n                        this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n                        const p2d = new Path2D(drawing.path);\n                        this.ctx.fill(p2d);\n                        this.ctx.restore();\n                    }\n                    else {\n                        console.error('Cannot render path2Dpattern. No defs/document defined.');\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    computeBBox(d) {\n        if (hasDocument) {\n            try {\n                const ns = 'http://www.w3.org/2000/svg';\n                const svg = document.createElementNS(ns, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(ns, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                document.body.appendChild(svg);\n                const bbox = pathNode.getBBox();\n                document.body.removeChild(svg);\n                return bbox;\n            }\n            catch (err) { }\n        }\n        return null;\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing) {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'qcurveTo':\n                    ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill();\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n}\n","import { RoughGenerator } from './generator';\nimport { RoughCanvasBase } from './canvas-base';\nexport class RoughCanvas extends RoughCanvasBase {\n    constructor(canvas, config) {\n        super(canvas);\n        this.gen = new RoughGenerator(config || null, this.canvas);\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { RoughGeneratorBase } from './generator-base';\nexport class RoughGeneratorAsync extends RoughGeneratorBase {\n    async line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [await this.lib.line(x1, y1, x2, y2, o)], o);\n    }\n    async rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(await this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(await this.lib.patternFillPolygon(points, o));\n            }\n        }\n        paths.push(await this.lib.rectangle(x, y, width, height, o));\n        return this._drawable('rectangle', paths, o);\n    }\n    async ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = await this.lib.ellipse(x, y, width, height, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(await this.lib.patternFillEllipse(x, y, width, height, o));\n            }\n        }\n        paths.push(await this.lib.ellipse(x, y, width, height, o));\n        return this._drawable('ellipse', paths, o);\n    }\n    async circle(x, y, diameter, options) {\n        const ret = await this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    async linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [await this.lib.linearPath(points, false, o)], o);\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = await this.lib.arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(await this.lib.patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        paths.push(await this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n        return this._drawable('arc', paths, o);\n    }\n    async curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [await this.lib.curve(points, o)], o);\n    }\n    async polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(await this.lib.solidFillPolygon(points, o));\n            }\n            else {\n                const size = this.computePolygonSize(points);\n                const fillPoints = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = await this.lib.patternFillPolygon(fillPoints, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = this.polygonPath(points);\n                paths.push(shape);\n            }\n        }\n        paths.push(await this.lib.linearPath(points, true, o));\n        return this._drawable('polygon', paths, o);\n    }\n    async path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = await this.lib.patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        paths.push(await this.lib.svgPath(d, o));\n        return this._drawable('path', paths, o);\n    }\n}\n","import { RoughGeneratorAsync } from './generator-async';\nimport { RoughCanvasBase } from './canvas-base';\nexport class RoughCanvasAsync extends RoughCanvasBase {\n    constructor(canvas, config) {\n        super(canvas);\n        this.genAsync = new RoughGeneratorAsync(config || null, this.canvas);\n    }\n    get generator() {\n        return this.genAsync;\n    }\n    getDefaultOptions() {\n        return this.genAsync.defaultOptions;\n    }\n    async line(x1, y1, x2, y2, options) {\n        const d = await this.genAsync.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    async rectangle(x, y, width, height, options) {\n        const d = await this.genAsync.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    async ellipse(x, y, width, height, options) {\n        const d = await this.genAsync.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    async circle(x, y, diameter, options) {\n        const d = await this.genAsync.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    async linearPath(points, options) {\n        const d = await this.genAsync.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    async polygon(points, options) {\n        const d = await this.genAsync.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = await this.genAsync.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    async curve(points, options) {\n        const d = await this.genAsync.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    async path(d, options) {\n        const drawing = await this.genAsync.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { RoughRenderer } from './renderer';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughSVGBase {\n    constructor(svg) {\n        this.svg = svg;\n    }\n    static createRenderer() {\n        return new RoughRenderer();\n    }\n    get defs() {\n        const doc = this.svg.ownerDocument || (hasDocument && document);\n        if (doc) {\n            if (!this._defs) {\n                const dnode = doc.createElementNS('http://www.w3.org/2000/svg', 'defs');\n                if (this.svg.firstChild) {\n                    this.svg.insertBefore(dnode, this.svg.firstChild);\n                }\n                else {\n                    this.svg.appendChild(dnode);\n                }\n                this._defs = dnode;\n            }\n        }\n        return this._defs || null;\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || (hasDocument && document);\n        const g = doc.createElementNS('http://www.w3.org/2000/svg', 'g');\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    path.setAttribute('d', this.opsToPath(drawing));\n                    path.style.stroke = o.stroke;\n                    path.style.strokeWidth = o.strokeWidth + '';\n                    path.style.fill = 'none';\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    path.setAttribute('d', this.opsToPath(drawing));\n                    path.style.stroke = 'none';\n                    path.style.strokeWidth = '0';\n                    path.style.fill = o.fill || null;\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n                case 'path2Dfill': {\n                    path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                    path.setAttribute('d', drawing.path || '');\n                    path.style.stroke = 'none';\n                    path.style.strokeWidth = '0';\n                    path.style.fill = o.fill || null;\n                    break;\n                }\n                case 'path2Dpattern': {\n                    if (!this.defs) {\n                        console.error('Cannot render path2Dpattern. No defs/document defined.');\n                    }\n                    else {\n                        const size = drawing.size;\n                        const pattern = doc.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n                        const id = `rough-${Math.floor(Math.random() * (Number.MAX_SAFE_INTEGER || 999999))}`;\n                        pattern.setAttribute('id', id);\n                        pattern.setAttribute('x', '0');\n                        pattern.setAttribute('y', '0');\n                        pattern.setAttribute('width', '1');\n                        pattern.setAttribute('height', '1');\n                        pattern.setAttribute('height', '1');\n                        pattern.setAttribute('viewBox', `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`);\n                        pattern.setAttribute('patternUnits', 'objectBoundingBox');\n                        const patternPath = this.fillSketch(doc, drawing, o);\n                        pattern.appendChild(patternPath);\n                        this.defs.appendChild(pattern);\n                        path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n                        path.setAttribute('d', drawing.path || '');\n                        path.style.stroke = 'none';\n                        path.style.strokeWidth = '0';\n                        path.style.fill = `url(#${id})`;\n                    }\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS('http://www.w3.org/2000/svg', 'path');\n        path.setAttribute('d', this.opsToPath(drawing));\n        path.style.stroke = o.fill || null;\n        path.style.strokeWidth = fweight + '';\n        path.style.fill = 'none';\n        return path;\n    }\n}\n","import { RoughGenerator } from './generator';\nimport { RoughSVGBase } from './svg-base';\nexport class RoughSVG extends RoughSVGBase {\n    constructor(svg, config) {\n        super(svg);\n        this.gen = new RoughGenerator(config || null, this.svg);\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing) {\n        return this.gen.opsToPath(drawing);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n","import { RoughGeneratorAsync } from './generator-async';\nimport { RoughSVGBase } from './svg-base';\nexport class RoughSVGAsync extends RoughSVGBase {\n    constructor(svg, config) {\n        super(svg);\n        this.genAsync = new RoughGeneratorAsync(config || null, this.svg);\n    }\n    get generator() {\n        return this.genAsync;\n    }\n    getDefaultOptions() {\n        return this.genAsync.defaultOptions;\n    }\n    opsToPath(drawing) {\n        return this.genAsync.opsToPath(drawing);\n    }\n    async line(x1, y1, x2, y2, options) {\n        const d = await this.genAsync.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    async rectangle(x, y, width, height, options) {\n        const d = await this.genAsync.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    async ellipse(x, y, width, height, options) {\n        const d = await this.genAsync.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    async circle(x, y, diameter, options) {\n        const d = await this.genAsync.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    async linearPath(points, options) {\n        const d = await this.genAsync.linearPath(points, options);\n        return this.draw(d);\n    }\n    async polygon(points, options) {\n        const d = await this.genAsync.polygon(points, options);\n        return this.draw(d);\n    }\n    async arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = await this.genAsync.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    async curve(points, options) {\n        const d = await this.genAsync.curve(points, options);\n        return this.draw(d);\n    }\n    async path(d, options) {\n        const drawing = await this.genAsync.path(d, options);\n        return this.draw(drawing);\n    }\n}\n","import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughGeneratorAsync } from './generator-async';\nimport { RoughCanvasAsync } from './canvas-async';\nimport { RoughSVG } from './svg';\nimport { RoughSVGAsync } from './svg-async';\nexport default {\n    canvas(canvas, config) {\n        if (config && config.async) {\n            return new RoughCanvasAsync(canvas, config);\n        }\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        if (config && config.async) {\n            return new RoughSVGAsync(svg, config);\n        }\n        return new RoughSVG(svg, config);\n    },\n    createRenderer() {\n        return RoughCanvas.createRenderer();\n    },\n    generator(config, surface) {\n        if (config && config.async) {\n            return new RoughGeneratorAsync(config, surface);\n        }\n        return new RoughGenerator(config, surface);\n    }\n};\n","import rough from 'roughjs'\n\nfunction Drawable () {\n  this.createAndAppend = function (parent) {\n    this.element = document.createElement('canvas')\n    parent.appendChild(this.element)\n    this.context2d = this.element.getContext('2d')\n    this.roughCanvas = rough.canvas(this.element)\n  }\n  this.resize = function (size) {\n    this.element.width = size.width\n    this.element.height = size.height\n  }\n  this.getSize = function () {\n    return {\n      width: this.element.width,\n      height: this.element.height\n    }\n  }\n  this.clear = function () {\n    this.context2d.clearRect(0, 0, this.element.width, this.element.height)\n  }\n\n  this.element = null\n  this.context2d = null\n  this.roughCanvas = null\n}\n\nexport default Drawable\n","function goFullscreen (elem) {\n  if (elem.requestFullscreen) {\n    elem.requestFullscreen()\n  } else if (elem.msRequestFullscreen) {\n    elem.msRequestFullscreen()\n  } else if (elem.mozRequestFullScreen) {\n    elem.mozRequestFullScreen()\n  } else if (elem.webkitRequestFullscreen) {\n    elem.webkitRequestFullscreen()\n  }\n}\n\nfunction FisherYatesShuffle (myArray) {\n  var i = myArray.length\n  var j\n  var tempi\n  var tempj\n  if (i === 0) return false\n  while (--i) {\n    j = Math.floor(Math.random() * (i + 1))\n    tempi = myArray[i]\n    tempj = myArray[j]\n    myArray[i] = tempj\n    myArray[j] = tempi\n  }\n  return myArray\n}\n\nfunction range (start, end, step) {\n  var range = []\n  var i\n  switch (arguments.length) {\n    case 1:\n      for (i = 0; i < start; i++) { range.push(i) }\n      break\n    case 2:\n      if (end > start) {\n        for (i = start; i < end; i++) { range.push(i) }\n      } else {\n        for (i = start; i > end; i--) { range.push(i) }\n      }\n      break\n    case 3:\n      if (start < end && step > 0) {\n        for (i = start; i < end;) { range.push(i); i += step }\n      } else if (start > end && step < 0) {\n        for (i = start; i > end;) { range.push(i); i += step }\n      }\n      break\n  }\n  return range\n}\n\nfunction distancePoints (p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2))\n}\n\nfunction distanceXY (x1, y1, x2, y2) {\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))\n}\n\n// 57.29577951308232 = 180 / Math.PI\nfunction rad2deg (d) {\n  return d * 57.29577951308232\n}\n\nfunction deg2rad (d) {\n  return d / 57.29577951308232\n}\n\nfunction angleBetweenXY (x1, y1, x2, y2) {\n  var a = Math.atan2(y2 - y1, x2 - x1)\n  console.log(a)\n  if (a < 0) { a += Math.PI * 2 }\n  return a\n}\n\nfunction pointFollowingAnglePoint (pos, angle, distance) {\n  // angle should be radians\n  // 0-360 0 mean east 90 south 180 west 270 north in degrees\n  return {\n    x: pos.x + Math.cos(angle) * distance,\n    y: pos.y + Math.sin(angle) * distance\n  }\n}\n\nfunction mapObj (func, obj) {\n  // iterate over objects keys\n  // func(obj , key, index)\n  var keys = Object.keys(obj)\n  var result = []\n  for (var i = 0; i < keys.length; i++) {\n    result.push(\n      func(obj[keys[i]], keys[i], i)\n    )\n  }\n  return result\n}\n\nfunction getWindowSizePoint () {\n  var winW = 0\n  var winH = 0\n  if (document.body && document.body.offsetWidth) {\n    winW = document.body.offsetWidth\n    winH = document.body.offsetHeight\n  }\n  if (document.compatMode === 'CSS1Compat' &&\n  document.documentElement &&\n  document.documentElement.offsetWidth) {\n    winW = document.documentElement.offsetWidth\n    winH = document.documentElement.offsetHeight\n  }\n  if (window.innerWidth && window.innerHeight) {\n    winW = window.innerWidth\n    winH = window.innerHeight\n  }\n  return {\n    width: winW,\n    height: winH\n  }\n}\n\nfunction getElementSize (element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  }\n}\n\nfunction downloadText (filename, text) {\n  // download content as a data test\n  var pom = document.createElement('a')\n  pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text))\n  pom.setAttribute('download', filename)\n  pom.click()\n}\n\nfunction getId (length) {\n  // with a length of 6 the first collision occurs after more than 9000000 of ids\n  var base62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  var str = ''\n  length = length || 10\n  for (let i = 0; i < length; i++) {\n    str += base62[Math.floor(Math.random() * 62)]\n  }\n  return str\n}\n// extracted from underscore\nfunction debounce (func, wait, immediate) {\n  var timeout\n  var result\n  return function () {\n    var context = this\n    var args = arguments\n    var later = function () {\n      timeout = null\n      if (!immediate) result = func.apply(context, args)\n    }\n    var callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow) result = func.apply(context, args)\n    return result\n  }\n}\n\nfunction throttle (func, wait) {\n  var context\n  var args\n  var timeout\n  var throttling\n  var more\n  var result\n  var whenDone = debounce(function () { more = throttling = false }, wait)\n  return function () {\n    context = this\n    args = arguments\n    var later = function () {\n      timeout = null\n      if (more) func.apply(context, args)\n      whenDone()\n    }\n    if (!timeout) timeout = setTimeout(later, wait)\n    if (throttling) {\n      more = true\n    } else {\n      result = func.apply(context, args)\n    }\n    whenDone()\n    throttling = true\n    return result\n  }\n}\n\nfunction changeColorLuminance (hex, lum) {\n  // validate hex string\n  hex = String(hex).replace(/[^0-9a-f]/gi, '')\n  if (hex.length < 6) {\n    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]\n  }\n  lum = lum || 0\n  // convert to decimal and change luminosity\n  var rgb = '#'\n  var c\n  var i\n  for (i = 0; i < 3; i++) {\n    c = parseInt(hex.substr(i * 2, 2), 16)\n    c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16)\n    rgb += ('00' + c).substr(c.length)\n  }\n  return rgb\n}\n\nfunction randomHexColor () {\n  var rgb = '#'\n  var c\n  var i\n  for (i = 0; i < 3; i++) {\n    c = Math.random() * 256\n    c = Math.round(Math.min(Math.max(0, c), 255)).toString(16)\n    rgb += ('00' + c).substr(c.length)\n  }\n  return rgb\n}\n\nfunction isTouchDevice () {\n  return 'ontouchstart' in window || 'onmsgesturechange' in window\n}\n\nexport {\n  debounce,\n  throttle,\n  getId,\n  downloadText,\n  getWindowSizePoint,\n  mapObj,\n  pointFollowingAnglePoint,\n  angleBetweenXY,\n  deg2rad,\n  rad2deg,\n  distancePoints,\n  distanceXY,\n  range,\n  FisherYatesShuffle,\n  goFullscreen,\n  isTouchDevice,\n  changeColorLuminance,\n  randomHexColor,\n  getElementSize\n}\n","/*\nRainbowVis-JS \nReleased under Eclipse Public License - v 1.0\n*/\n\nfunction Rainbow()\n{\n\t\"use strict\";\n\tvar gradients = null;\n\tvar minNum = 0;\n\tvar maxNum = 100;\n\tvar colours = ['ff0000', 'ffff00', '00ff00', '0000ff']; \n\tsetColours(colours);\n\t\n\tfunction setColours (spectrum) \n\t{\n\t\tif (spectrum.length < 2) {\n\t\t\tthrow new Error('Rainbow must have two or more colours.');\n\t\t} else {\n\t\t\tvar increment = (maxNum - minNum)/(spectrum.length - 1);\n\t\t\tvar firstGradient = new ColourGradient();\n\t\t\tfirstGradient.setGradient(spectrum[0], spectrum[1]);\n\t\t\tfirstGradient.setNumberRange(minNum, minNum + increment);\n\t\t\tgradients = [ firstGradient ];\n\t\t\t\n\t\t\tfor (var i = 1; i < spectrum.length - 1; i++) {\n\t\t\t\tvar colourGradient = new ColourGradient();\n\t\t\t\tcolourGradient.setGradient(spectrum[i], spectrum[i + 1]);\n\t\t\t\tcolourGradient.setNumberRange(minNum + increment * i, minNum + increment * (i + 1)); \n\t\t\t\tgradients[i] = colourGradient; \n\t\t\t}\n\n\t\t\tcolours = spectrum;\n\t\t}\n\t}\n\n\tthis.setSpectrum = function () \n\t{\n\t\tsetColours(arguments);\n\t\treturn this;\n\t}\n\n\tthis.setSpectrumByArray = function (array)\n\t{\n\t\tsetColours(array);\n\t\treturn this;\n\t}\n\n\tthis.colourAt = function (number)\n\t{\n\t\tif (isNaN(number)) {\n\t\t\tthrow new TypeError(number + ' is not a number');\n\t\t} else if (gradients.length === 1) {\n\t\t\treturn gradients[0].colourAt(number);\n\t\t} else {\n\t\t\tvar segment = (maxNum - minNum)/(gradients.length);\n\t\t\tvar index = Math.min(Math.floor((Math.max(number, minNum) - minNum)/segment), gradients.length - 1);\n\t\t\treturn gradients[index].colourAt(number);\n\t\t}\n\t}\n\n\tthis.colorAt = this.colourAt;\n\n\tthis.setNumberRange = function (minNumber, maxNumber)\n\t{\n\t\tif (maxNumber > minNumber) {\n\t\t\tminNum = minNumber;\n\t\t\tmaxNum = maxNumber;\n\t\t\tsetColours(colours);\n\t\t} else {\n\t\t\tthrow new RangeError('maxNumber (' + maxNumber + ') is not greater than minNumber (' + minNumber + ')');\n\t\t}\n\t\treturn this;\n\t}\n}\n\nfunction ColourGradient() \n{\n\t\"use strict\";\n\tvar startColour = 'ff0000';\n\tvar endColour = '0000ff';\n\tvar minNum = 0;\n\tvar maxNum = 100;\n\n\tthis.setGradient = function (colourStart, colourEnd)\n\t{\n\t\tstartColour = getHexColour(colourStart);\n\t\tendColour = getHexColour(colourEnd);\n\t}\n\n\tthis.setNumberRange = function (minNumber, maxNumber)\n\t{\n\t\tif (maxNumber > minNumber) {\n\t\t\tminNum = minNumber;\n\t\t\tmaxNum = maxNumber;\n\t\t} else {\n\t\t\tthrow new RangeError('maxNumber (' + maxNumber + ') is not greater than minNumber (' + minNumber + ')');\n\t\t}\n\t}\n\n\tthis.colourAt = function (number)\n\t{\n\t\treturn calcHex(number, startColour.substring(0,2), endColour.substring(0,2)) \n\t\t\t+ calcHex(number, startColour.substring(2,4), endColour.substring(2,4)) \n\t\t\t+ calcHex(number, startColour.substring(4,6), endColour.substring(4,6));\n\t}\n\t\n\tfunction calcHex(number, channelStart_Base16, channelEnd_Base16)\n\t{\n\t\tvar num = number;\n\t\tif (num < minNum) {\n\t\t\tnum = minNum;\n\t\t}\n\t\tif (num > maxNum) {\n\t\t\tnum = maxNum;\n\t\t} \n\t\tvar numRange = maxNum - minNum;\n\t\tvar cStart_Base10 = parseInt(channelStart_Base16, 16);\n\t\tvar cEnd_Base10 = parseInt(channelEnd_Base16, 16); \n\t\tvar cPerUnit = (cEnd_Base10 - cStart_Base10)/numRange;\n\t\tvar c_Base10 = Math.round(cPerUnit * (num - minNum) + cStart_Base10);\n\t\treturn formatHex(c_Base10.toString(16));\n\t}\n\n\tfunction formatHex(hex) \n\t{\n\t\tif (hex.length === 1) {\n\t\t\treturn '0' + hex;\n\t\t} else {\n\t\t\treturn hex;\n\t\t}\n\t} \n\t\n\tfunction isHexColour(string)\n\t{\n\t\tvar regex = /^#?[0-9a-fA-F]{6}$/i;\n\t\treturn regex.test(string);\n\t}\n\n\tfunction getHexColour(string)\n\t{\n\t\tif (isHexColour(string)) {\n\t\t\treturn string.substring(string.length - 6, string.length);\n\t\t} else {\n\t\t\tvar name = string.toLowerCase();\n\t\t\tif (colourNames.hasOwnProperty(name)) {\n\t\t\t\treturn colourNames[name];\n\t\t\t}\n\t\t\tthrow new Error(string + ' is not a valid colour.');\n\t\t}\n\t}\n\t\n\t// Extended list of CSS colornames s taken from\n\t// http://www.w3.org/TR/css3-color/#svg-color\n\tvar colourNames = {\n\t\taliceblue: \"F0F8FF\",\n\t\tantiquewhite: \"FAEBD7\",\n\t\taqua: \"00FFFF\",\n\t\taquamarine: \"7FFFD4\",\n\t\tazure: \"F0FFFF\",\n\t\tbeige: \"F5F5DC\",\n\t\tbisque: \"FFE4C4\",\n\t\tblack: \"000000\",\n\t\tblanchedalmond: \"FFEBCD\",\n\t\tblue: \"0000FF\",\n\t\tblueviolet: \"8A2BE2\",\n\t\tbrown: \"A52A2A\",\n\t\tburlywood: \"DEB887\",\n\t\tcadetblue: \"5F9EA0\",\n\t\tchartreuse: \"7FFF00\",\n\t\tchocolate: \"D2691E\",\n\t\tcoral: \"FF7F50\",\n\t\tcornflowerblue: \"6495ED\",\n\t\tcornsilk: \"FFF8DC\",\n\t\tcrimson: \"DC143C\",\n\t\tcyan: \"00FFFF\",\n\t\tdarkblue: \"00008B\",\n\t\tdarkcyan: \"008B8B\",\n\t\tdarkgoldenrod: \"B8860B\",\n\t\tdarkgray: \"A9A9A9\",\n\t\tdarkgreen: \"006400\",\n\t\tdarkgrey: \"A9A9A9\",\n\t\tdarkkhaki: \"BDB76B\",\n\t\tdarkmagenta: \"8B008B\",\n\t\tdarkolivegreen: \"556B2F\",\n\t\tdarkorange: \"FF8C00\",\n\t\tdarkorchid: \"9932CC\",\n\t\tdarkred: \"8B0000\",\n\t\tdarksalmon: \"E9967A\",\n\t\tdarkseagreen: \"8FBC8F\",\n\t\tdarkslateblue: \"483D8B\",\n\t\tdarkslategray: \"2F4F4F\",\n\t\tdarkslategrey: \"2F4F4F\",\n\t\tdarkturquoise: \"00CED1\",\n\t\tdarkviolet: \"9400D3\",\n\t\tdeeppink: \"FF1493\",\n\t\tdeepskyblue: \"00BFFF\",\n\t\tdimgray: \"696969\",\n\t\tdimgrey: \"696969\",\n\t\tdodgerblue: \"1E90FF\",\n\t\tfirebrick: \"B22222\",\n\t\tfloralwhite: \"FFFAF0\",\n\t\tforestgreen: \"228B22\",\n\t\tfuchsia: \"FF00FF\",\n\t\tgainsboro: \"DCDCDC\",\n\t\tghostwhite: \"F8F8FF\",\n\t\tgold: \"FFD700\",\n\t\tgoldenrod: \"DAA520\",\n\t\tgray: \"808080\",\n\t\tgreen: \"008000\",\n\t\tgreenyellow: \"ADFF2F\",\n\t\tgrey: \"808080\",\n\t\thoneydew: \"F0FFF0\",\n\t\thotpink: \"FF69B4\",\n\t\tindianred: \"CD5C5C\",\n\t\tindigo: \"4B0082\",\n\t\tivory: \"FFFFF0\",\n\t\tkhaki: \"F0E68C\",\n\t\tlavender: \"E6E6FA\",\n\t\tlavenderblush: \"FFF0F5\",\n\t\tlawngreen: \"7CFC00\",\n\t\tlemonchiffon: \"FFFACD\",\n\t\tlightblue: \"ADD8E6\",\n\t\tlightcoral: \"F08080\",\n\t\tlightcyan: \"E0FFFF\",\n\t\tlightgoldenrodyellow: \"FAFAD2\",\n\t\tlightgray: \"D3D3D3\",\n\t\tlightgreen: \"90EE90\",\n\t\tlightgrey: \"D3D3D3\",\n\t\tlightpink: \"FFB6C1\",\n\t\tlightsalmon: \"FFA07A\",\n\t\tlightseagreen: \"20B2AA\",\n\t\tlightskyblue: \"87CEFA\",\n\t\tlightslategray: \"778899\",\n\t\tlightslategrey: \"778899\",\n\t\tlightsteelblue: \"B0C4DE\",\n\t\tlightyellow: \"FFFFE0\",\n\t\tlime: \"00FF00\",\n\t\tlimegreen: \"32CD32\",\n\t\tlinen: \"FAF0E6\",\n\t\tmagenta: \"FF00FF\",\n\t\tmaroon: \"800000\",\n\t\tmediumaquamarine: \"66CDAA\",\n\t\tmediumblue: \"0000CD\",\n\t\tmediumorchid: \"BA55D3\",\n\t\tmediumpurple: \"9370DB\",\n\t\tmediumseagreen: \"3CB371\",\n\t\tmediumslateblue: \"7B68EE\",\n\t\tmediumspringgreen: \"00FA9A\",\n\t\tmediumturquoise: \"48D1CC\",\n\t\tmediumvioletred: \"C71585\",\n\t\tmidnightblue: \"191970\",\n\t\tmintcream: \"F5FFFA\",\n\t\tmistyrose: \"FFE4E1\",\n\t\tmoccasin: \"FFE4B5\",\n\t\tnavajowhite: \"FFDEAD\",\n\t\tnavy: \"000080\",\n\t\toldlace: \"FDF5E6\",\n\t\tolive: \"808000\",\n\t\tolivedrab: \"6B8E23\",\n\t\torange: \"FFA500\",\n\t\torangered: \"FF4500\",\n\t\torchid: \"DA70D6\",\n\t\tpalegoldenrod: \"EEE8AA\",\n\t\tpalegreen: \"98FB98\",\n\t\tpaleturquoise: \"AFEEEE\",\n\t\tpalevioletred: \"DB7093\",\n\t\tpapayawhip: \"FFEFD5\",\n\t\tpeachpuff: \"FFDAB9\",\n\t\tperu: \"CD853F\",\n\t\tpink: \"FFC0CB\",\n\t\tplum: \"DDA0DD\",\n\t\tpowderblue: \"B0E0E6\",\n\t\tpurple: \"800080\",\n\t\tred: \"FF0000\",\n\t\trosybrown: \"BC8F8F\",\n\t\troyalblue: \"4169E1\",\n\t\tsaddlebrown: \"8B4513\",\n\t\tsalmon: \"FA8072\",\n\t\tsandybrown: \"F4A460\",\n\t\tseagreen: \"2E8B57\",\n\t\tseashell: \"FFF5EE\",\n\t\tsienna: \"A0522D\",\n\t\tsilver: \"C0C0C0\",\n\t\tskyblue: \"87CEEB\",\n\t\tslateblue: \"6A5ACD\",\n\t\tslategray: \"708090\",\n\t\tslategrey: \"708090\",\n\t\tsnow: \"FFFAFA\",\n\t\tspringgreen: \"00FF7F\",\n\t\tsteelblue: \"4682B4\",\n\t\ttan: \"D2B48C\",\n\t\tteal: \"008080\",\n\t\tthistle: \"D8BFD8\",\n\t\ttomato: \"FF6347\",\n\t\tturquoise: \"40E0D0\",\n\t\tviolet: \"EE82EE\",\n\t\twheat: \"F5DEB3\",\n\t\twhite: \"FFFFFF\",\n\t\twhitesmoke: \"F5F5F5\",\n\t\tyellow: \"FFFF00\",\n\t\tyellowgreen: \"9ACD32\"\n\t}\n}\n\nif (typeof module !== 'undefined') {\n  module.exports = Rainbow;\n}\n","import './style.css'\nimport Drawable from './drawable'\nimport {FisherYatesShuffle, getWindowSizePoint, changeColorLuminance, throttle, range, randomHexColor} from './helpers'\nimport Rainbow from 'rainbowvis.js'\n\nconst TOP_LINE = 1\nconst RIGHT_LINE = 2\nconst BOTTOM_LINE = 4\nconst LEFT_LINE = 8\nconst ALL_LINES = TOP_LINE + RIGHT_LINE + BOTTOM_LINE + LEFT_LINE\n\nfunction drawGrid (drawable, width, height, size) {\n  let roughCanvas = drawable.roughCanvas\n  let options = {\n    stroke: 'rgb(0, 0, 0, 0.5)',\n    strokeWidth: size / 10,\n    bowing: 0.6\n  }\n  let gridOptions = {\n    roughness: 0.6,\n    stroke: 'rgb(203, 255, 241, 0.7)',\n    strokeWidth: size / 40\n  }\n  let top = 0\n  let bottom = height * size\n  let left = 0\n  let right = width * size\n  range(left, right, size).forEach((position) => {\n    // vertical lines\n    roughCanvas.line(\n      position, bottom,\n      position, top,\n      gridOptions\n    )\n  })\n  range(top, bottom, size).forEach((position) => {\n    // horizontal lines\n    roughCanvas.line(\n      left, position,\n      right, position,\n      gridOptions\n    )\n  })\n  // top left > top right\n  roughCanvas.line(\n    left, top,\n    right, top,\n    options\n  )\n  // top right > bottom right\n  roughCanvas.line(\n    right, top,\n    right, bottom,\n    options\n  )\n  // bottom right > bottom left\n  roughCanvas.line(\n    right, bottom,\n    left, bottom,\n    options\n  )\n  // bottom left > top left\n  roughCanvas.line(\n    left, bottom,\n    left, top,\n    options\n  )\n}\n\n/*\ndata.x = 10 // canvas relative\ndata.y = 10 // canvas relative\ndata.size = 10\ndata.color = color\n// add transparency\ndata.strokeColor = changeColorLuminance(this.color, -0.7) + '80'\n\n*/\n\nfunction drawNormalBlockLines (drawable, data) {\n  var roughCanvas = drawable.roughCanvas\n  var offset = data.size * 0.12 // this will draw lines outside the block\n  var left = data.x\n  var top = data.y\n  var bottom = data.y + data.size\n  var right = data.x + data.size\n  // strokeWidth\n  var lineOptions = {\n    strokeWidth: data.size * 0.06,\n    stroke: data.strokeColor\n  }\n  // top line\n  if (data.lines & 1) {\n    roughCanvas.line(left - offset, top, right + offset, top, lineOptions)\n  }\n  // right line\n  if (data.lines >> 1 & 1) {\n    roughCanvas.line(right, top - offset, right, bottom + offset, lineOptions)\n  }\n  // bottom line\n  if (data.lines >> 2 & 1) {\n    roughCanvas.line(left - offset, bottom, right + offset, bottom, lineOptions)\n  }\n  // left line\n  if (data.lines >> 3 & 1) {\n    roughCanvas.line(left, top - offset, left, bottom + offset, lineOptions)\n  }\n}\n\nfunction drawBlock (drawable, data) {\n  let roughCanvas = drawable.roughCanvas\n  // draw the block\n  var margin = data.size * 0.1\n  var left = data.x\n  var right = data.x + data.size\n  var top = data.y\n  var bottom = data.y + data.size\n  /*\n  Block diagram from drawing margins\n\n  ##b##c##\n  ##-##-##\n  e-f##g-h\n  ########\n  ########\n  i-j##k-l\n  ##-##-##\n  ##n##o##\n  */\n\n  var b = [left + margin, top]\n  var c = [right - margin, top]\n\n  var e = [left, top + margin]\n  var f = [left + margin, top + margin]\n  var g = [right - margin, top + margin]\n  var h = [right, top + margin]\n\n  var i = [left, bottom - margin]\n  var j = [left + margin, bottom - margin]\n  var k = [right - margin, bottom - margin]\n  var l = [right, bottom - margin]\n\n  var n = [left + margin, bottom]\n  var o = [right - margin, bottom]\n\n  var lines = []\n  var points = []\n  switch (data.lines) {\n    case ALL_LINES:\n      points = [f, g, k, j]\n      lines = [\n        [f, g], [g, k], [k, j], [j, f]\n      ]\n      break\n    case TOP_LINE + BOTTOM_LINE:\n      points = [e, h, l, i]\n      lines = [[e, h], [l, i]]\n      break\n    case LEFT_LINE + RIGHT_LINE:\n      points = [b, c, o, n]\n      lines = [[b, n], [c, o]]\n      break\n    case ALL_LINES - TOP_LINE:\n      points = [b, c, k, j]\n      lines = [\n        [c, k], [k, j], [j, b]\n      ]\n      break\n    case ALL_LINES - RIGHT_LINE:\n      points = [f, h, l, j]\n      lines = [\n        [f, h], [l, j], [j, f]\n      ]\n      break\n    case ALL_LINES - BOTTOM_LINE:\n      points = [f, g, o, n]\n      lines = [\n        [f, g], [g, o], [n, f]\n      ]\n      break\n    case ALL_LINES - LEFT_LINE:\n      points = [e, g, k, i]\n      lines = [\n        [e, g], [g, k], [k, i]\n      ]\n      break\n    case LEFT_LINE + BOTTOM_LINE:\n      points = [j, b, c, g, h, l]\n      lines = [[c, g], [g, h], [l, j], [j, b]]\n      break\n    case LEFT_LINE + TOP_LINE:\n      points = [f, h, l, k, o, n]\n      lines = [[f, h], [l, k], [k, o], [n, f]]\n      break\n    case RIGHT_LINE + BOTTOM_LINE:\n      points = [e, f, b, c, k, i]\n      lines = [[e, f], [f, b], [c, k], [k, i]]\n      break\n    case RIGHT_LINE + TOP_LINE:\n      points = [e, g, o, n, j, i]\n      lines = [[e, g], [g, o], [n, j], [j, i]]\n      break\n  }\n\n  roughCanvas.polygon(points, {\n    hachureAngle: data.hachureAngle,\n    hachureGap: 4,\n    roughness: 1.8,\n    stroke: 'rgba(0,0,0,0.1)',\n    fill: data.color,\n    fillStyle: 'zigzag' // solid fill\n  })\n\n  var lineOptions = {\n    strokeWidth: data.size * 0.06,\n    stroke: data.strokeColor\n  }\n\n  lines.forEach(line => {\n    roughCanvas.line(line[0][0], line[0][1], line[1][0], line[1][1], lineOptions)\n  })\n}\n\nfunction drawNormalBlock (drawable, data) {\n  let roughCanvas = drawable.roughCanvas\n  // draw the block\n\n  roughCanvas.rectangle(data.x, data.y, data.size, data.size, {\n    hachureAngle: data.hachureAngle,\n    hachureGap: 4,\n    roughness: 1.8,\n    stroke: 'rgba(0,0,0,0.1)',\n    fill: data.color,\n    fillStyle: 'zigzag' // solid fill\n  })\n  drawNormalBlockLines(drawable, data)\n}\n\nfunction getGrayShade (value) {\n  // value must be between 0-255\n  var c = Math.round(value).toString(16)\n  c = ('00' + c).substr(c.length)\n  return '#' + c + c + c\n}\n\nfunction Snaker (drawable) {\n  this.size = 30 // square size\n  this.width = 15 // number of squares to draw\n  this.height = 15\n  this.color = '#F44336'\n  this.strokeColor = changeColorLuminance(this.color, -0.7) + '80'\n  this.visitedPositions = []\n  this.intialPositions = []\n  this.blocksPending = []\n  this.drawable = drawable\n  this.colorIndex = 0\n  this.rainbow = new Rainbow()\n  this.grayScaleColors = range(0, 200, 50).map(value => {\n    return getGrayShade(value)\n  })\n  \n  this.setSpectrum = function () {\n    this.rainbow.setNumberRange(0, 40)\n\n    switch (parseInt(Math.random() * 4)) {\n      case 0:\n        this.rainbow.setSpectrum('#000000', '#327fb1', '#ffaf55')\n        break\n      case 1:\n        this.rainbow.setSpectrum('#c39de0', '#9e62cc', '#824f8a', '#441c63', '#ff0000', '#310752', '#170326', '#f0cba3')\n        break\n      case 2:\n        this.rainbow.setSpectrum(randomHexColor(), randomHexColor(), randomHexColor())\n      case 3:\n        this.rainbow.setSpectrum(randomHexColor(), randomHexColor(), randomHexColor(), randomHexColor(), randomHexColor(), randomHexColor())\n    }\n\n    this.colors = range(0, 40).map((c) => {\n      return '#' + this.rainbow.colorAt(c)\n    }).concat(\n      range(40, 0).map((c) => {\n        return '#' + this.rainbow.colorAt(c)\n      })\n    )\n  }\n  this.reset = function () {\n    this.setSpectrum()\n    this.size = parseInt(Math.random() * 40) + 20\n    this.blocksPending = []\n    this.drawable.clear()\n    this.visitedPositions = []\n    this.setGridSize(this.width, this.height)\n  }\n\n  this.drawGrid = function () {\n    drawGrid(this.drawable, this.width, this.height, this.size)\n  }\n\n  this.nextColor = function () {\n    this.color = this.colors[this.colorIndex]\n    this.strokeColor = changeColorLuminance(this.color, -0.7) + '80'\n    this.colorIndex += 1\n    this.colorIndex %= this.colors.length\n  }\n\n  this.drawTillEnd = function () {\n    while (true) {\n      try {\n        this.draw()\n      } catch (e) {\n        return\n      }\n    }\n  }\n  this.draw = function () {\n    this.nextColor()\n    var snake = this.getSnake()\n    snake.forEach(dataPoint => {\n      this.blocksPending.push({\n        x: dataPoint.point[0] * this.size,\n        y: dataPoint.point[1] * this.size,\n        size: this.size,\n        color: this.color,\n        strokeColor: this.strokeColor,\n        hachureAngle: dataPoint.hachureAngle,\n        lines: dataPoint.lines\n      })\n      this.nextColor()\n      /*\n      data.x = dataPoint.point[0] * this.size\n      data.y = dataPoint.point[1] * this.size\n      data.lines = dataPoint.lines\n      data.color = dataPoint.color ? dataPoint.color : this.color\n      data.strokeColor = dataPoint.strokeColor ? dataPoint.strokeColor : this.strokeColor\n      data.hachureAngle = dataPoint.hachureAngle\n      drawBlock(this.drawable, data)\n      */\n    })\n  }\n  this.drawLoop = function () {\n    setInterval(() => {\n      var data = this.blocksPending.shift()\n      if (data) {\n        drawBlock(this.drawable, data)\n      }\n    }, 20)\n  }\n  this.getEmptyPoint = function () {\n    if (this.visitedPositions.length >= this.width * this.height) {\n      throw Error('No more positions available')\n    }\n    if (this.intialPositions.length === 0) {\n      // we still have empty place because we if all were visited before\n      this.setGridSize(this.width, this.height)\n    }\n    let position = this.intialPositions.pop()\n    if (!this.isVisited(position)) {\n      return position\n    }\n    return this.getEmptyPoint()\n  }\n\n  this.markVisited = function (x, y) {\n    if (y === undefined) {\n      return this.visitedPositions.push(`${x[0]}-${x[1]}`)\n    }\n    return this.visitedPositions.push(`${x}-${y}`)\n  }\n\n  this.isVisited = function (x, y) {\n    if (y === undefined) {\n      return this.isVisited(x[0], x[1])\n    }\n    if (x < 0 || x >= this.width) {\n      return true\n    }\n    if (y < 0 || y >= this.height) {\n      return true\n    }\n    return this.visitedPositions.includes(`${x}-${y}`)\n  }\n\n  this.getSnakeNextPoint = function (dataPoint) {\n    var directions = FisherYatesShuffle(['t', 'r', 'b', 'l'])\n    for (let i = 0; i < directions.length; i++) {\n      const direction = directions[i]\n      const nextPoint = dataPoint.point.slice()\n      switch (direction) {\n        case 't':\n          nextPoint[1] -= 1\n          break\n        case 'r':\n          nextPoint[0] += 1\n          break\n        case 'b':\n          nextPoint[1] += 1\n          break\n        case 'l':\n          nextPoint[0] -= 1\n          break\n      }\n      if (!this.isVisited(nextPoint)) {\n        return {\n          direction: direction,\n          nextPoint: nextPoint\n        }\n      }\n    }\n\n    return {\n      direction: undefined,\n      nextPoint: undefined\n    }\n  }\n\n  this.getLinesForDirections = function (previousDirection, direction) {\n    var lines = ALL_LINES\n    switch (direction) {\n      case 't':\n        lines = LEFT_LINE + RIGHT_LINE + BOTTOM_LINE\n        break\n      case 'r':\n        lines = LEFT_LINE + TOP_LINE + BOTTOM_LINE\n        break\n      case 'b':\n        lines = LEFT_LINE + RIGHT_LINE + TOP_LINE\n        break\n      case 'l':\n        lines = RIGHT_LINE + TOP_LINE + BOTTOM_LINE\n        break\n      case undefined:\n        lines = ALL_LINES\n        break\n    }\n    if (previousDirection !== undefined) {\n      switch (previousDirection) {\n        case 't':\n          lines -= BOTTOM_LINE\n          break\n        case 'r':\n          lines -= LEFT_LINE\n          break\n        case 'b':\n          lines -= TOP_LINE\n          break\n        case 'l':\n          lines -= RIGHT_LINE\n          break\n      }\n    }\n    return lines\n  }\n\n  this.getHachureAngleForDirections = function (previousDirection, direction) {\n    var hachureAngle = 0\n    switch (`${previousDirection}-${direction}`) {\n      case 't-b':\n      case 'b-t':\n      case 't-t':\n      case 'b-b':\n      case 't-undefined':\n      case 'b-undefined':\n      case 'undefined-t':\n      case 'undefined-b':\n        hachureAngle = 0\n        break\n      case 'l-r':\n      case 'r-l':\n      case 'r-r':\n      case 'l-l':\n      case 'r-undefined':\n      case 'l-undefined':\n      case 'undefined-r':\n      case 'undefined-l':\n        hachureAngle = 90\n        break\n      case 'r-b':\n      case 'b-r':\n      case 't-l':\n      case 'l-t':\n        hachureAngle = 45\n        break\n      case 'l-b':\n      case 'b-l':\n      case 't-r':\n      case 'r-t':\n        hachureAngle = -45\n        break\n      case 'undefined-undefined':\n        hachureAngle = 0\n        break\n    }\n    return hachureAngle\n  }\n\n  this.getSnake = function (snake, dataPoint, previousDirection) {\n    snake = snake === undefined ? [] : snake\n    if (dataPoint === undefined) {\n      dataPoint = {\n        point: this.getEmptyPoint()\n      }\n    }\n    snake.push(dataPoint)\n    this.markVisited(dataPoint.point)\n    var {direction, nextPoint} = this.getSnakeNextPoint(dataPoint)\n    dataPoint.lines = this.getLinesForDirections(previousDirection, direction)\n    dataPoint.hachureAngle = this.getHachureAngleForDirections(previousDirection, direction)\n    if (nextPoint) {\n      return this.getSnake(snake, {point: nextPoint}, direction)\n    }\n    return snake\n  }\n  this.setGridSize = function (width, height) {\n    this.width = width\n    this.height = height\n    this.intialPositions = []\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        this.intialPositions.push([x, y])\n      }\n    }\n    this.intialPositions = FisherYatesShuffle(this.intialPositions)\n  }\n  this.resize = function () {\n    this.reset()\n    let size = this.drawable.getSize()\n    this.setGridSize(\n      parseInt(size.width / this.size),\n      parseInt(size.height / this.size)\n    )\n  }\n}\n\n// initialization\nvar drawable = new Drawable()\nvar snaker = new Snaker(drawable)\n\nwindow.addEventListener('load', function () {\n  let main = document.getElementById('main')\n  drawable.createAndAppend(main)\n  let size = getWindowSizePoint()\n  drawable.resize(size)\n  snaker.resize()\n  snaker.drawLoop()\n  snaker.drawGrid()\n  snaker.drawTillEnd()\n})\n\nwindow.addEventListener('resize', throttle(function () {\n  let size = getWindowSizePoint()\n  drawable.resize(size)\n  snaker.resize()\n  snaker.drawGrid()\n}, 200))\n\nwindow.addEventListener('keydown', (e) => {\n  switch (e.which) {\n    case 82:\n      // r\n      try {\n        snaker.draw()\n      } catch (e) {\n        return\n      }\n      break\n    case 69:\n      // e\n      snaker.resize()\n      snaker.drawGrid()\n      break\n    case 87:\n      // w\n      snaker.drawTillEnd()\n      break\n    default:\n      console.log(e.which)\n  }\n})\n\nconsole.log(`\nUse \"r\" to draw a single snake\nUse \"e\" to cause a resize and a reset\nUse \"w\" to draw snakes till everything is filled\n`)\nexport default {}\n"]}